import streamlit as st
import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import copy
from new_clustering_rules import PLUM_RULES, NECT_RULES
from common_styles import configure_page, generarMenu, get_cluster_colors

# Configuraci√≥n de p√°gina con estilos unificados
configure_page("M√©tricas y Bandas", "üìä")

# CSS personalizado adicional para esta p√°gina
st.markdown("""
<style>
    .rule-editor {
        background: linear-gradient(135deg, var(--success-green) 0%, var(--success-green-dark) 100%);
        padding: 1.5rem;
        border-radius: 15px;
        color: white;
        margin: 1rem 0;
        box-shadow: 0 8px 32px rgba(16, 185, 129, 0.3);
    }
    
    .stTab > div > div > div > div {
        padding: 2rem 1rem;
    }
    
    .band-input {
        background: rgba(255, 255, 255, 0.1);
        border: 1px solid var(--border-light);
        border-radius: 8px;
        padding: 0.5rem;
        color: var(--text-dark);
    }
</style>
""", unsafe_allow_html=True)

# Men√∫ de navegaci√≥n

generarMenu()

st.title("üéØ Editor Avanzado de M√©tricas y Bandas")

st.markdown("""
<div class="metric-card">
    <h3>üöÄ Sistema Interactivo de Reglas de Clustering</h3>
    <p>Configure y personalice las reglas de clasificaci√≥n para diferentes especies y per√≠odos de cosecha.</p>
    <p><strong>‚ú® Funcionalidades:</strong> Edici√≥n en tiempo real ‚Ä¢ Validaci√≥n autom√°tica ‚Ä¢ Visualizaciones interactivas ‚Ä¢ Exportaci√≥n de configuraciones</p>
</div>
""", unsafe_allow_html=True)

# Inicializar session state para las reglas editables
if "edited_plum_rules" not in st.session_state:
    st.session_state.edited_plum_rules = copy.deepcopy(PLUM_RULES)
if "edited_nect_rules" not in st.session_state:
    st.session_state.edited_nect_rules = copy.deepcopy(NECT_RULES)

# Funci√≥n para crear sliders de bandas
def create_band_editor(metric_name, current_bands, key_prefix):
    st.markdown(f"#### üìè {metric_name}")
    
    # Extraer valores actuales
    values = []
    for lo, hi, band in current_bands:
        if lo != float('-inf'):
            values.append(lo)
        if hi != float('inf'):
            values.append(hi)
    
    # Determinar rango
    if values:
        min_val = min(values) - 5
        max_val = max(values) + 5
    else:
        min_val, max_val = 0, 25
    
    # Editor de bandas
    col1, col2, col3 = st.columns(3)
    
    new_bands = []
    band_colors = ["üü¢", "üü°", "üü†", "üü£"]
    
    for i, (lo, hi, band) in enumerate(current_bands):
        with [col1, col2, col3][i % 3]:
            st.markdown(f"**{band_colors[band-1]} Banda {band}**")
            
            # Manejar infinitos
            lo_display = lo if lo != float('-inf') else min_val
            hi_display = hi if hi != float('inf') else max_val
            
            # Sliders para l√≠mites
            if lo != float('-inf'):
                new_lo = st.slider(
                    f"M√≠nimo B{band}", 
                    min_val, max_val, 
                    float(lo_display), 
                    step=0.1,
                    key=f"{key_prefix}_lo_{i}"
                )
            else:
                new_lo = float('-inf')
                st.info("M√≠nimo: -‚àû")
            
            if hi != float('inf'):
                new_hi = st.slider(
                    f"M√°ximo B{band}", 
                    min_val, max_val, 
                    float(hi_display), 
                    step=0.1,
                    key=f"{key_prefix}_hi_{i}"
                )
            else:
                new_hi = float('inf')
                st.info("M√°ximo: +‚àû")
            
            new_bands.append((new_lo, new_hi, band))
    
    return new_bands

# Funci√≥n para visualizar bandas
def create_band_visualization(metric_name, bands, title):
    fig = go.Figure()
    
    # Usar paleta pastel est√°ndar
    cluster_colors = get_cluster_colors()
    colors = [cluster_colors['hex'][i] for i in range(1, 5)]
    
    for lo, hi, band in bands:
        lo_display = lo if lo != float('-inf') else 0
        hi_display = hi if hi != float('inf') else 25
        
        fig.add_trace(go.Scatter(
            x=[lo_display, hi_display, hi_display, lo_display, lo_display],
            y=[band-0.4, band-0.4, band+0.4, band+0.4, band-0.4],
            fill="toself",
            fillcolor=colors[band-1],
            opacity=0.6,
            line=dict(color=colors[band-1], width=2),
            name=f"Banda {band}",
            text=f"Banda {band}: [{lo}, {hi})",
            hovertemplate="%{text}<extra></extra>"
        ))
    
    fig.update_layout(
        title=f"üìä Visualizaci√≥n de Bandas - {title}",
        xaxis_title=metric_name,
        yaxis_title="Banda",
        yaxis=dict(tickmode='linear', tick0=1, dtick=1),
        showlegend=True,
        height=300,
        template="plotly_dark"
    )
    
    return fig

# Tabs principales
tab1, tab2, tab3, tab4, tab5 = st.tabs(["üçë Editor Ciruela", "üçë Editor Nectarina", "üìä Visualizaciones", "‚öôÔ∏è Configuraci√≥n", "‚ûï Crear M√©tricas"])

with tab1:
    st.markdown("""
    <div class="rule-editor">
        <h3>üç≠ Editor de Reglas para Ciruela</h3>
        <p>Configure las bandas de clasificaci√≥n para Candy Plum (>60g) y Cherry Plum (‚â§60g)</p>
    </div>
    """, unsafe_allow_html=True)
    
    plum_type = st.selectbox("üéØ Seleccionar Tipo de Ciruela", ["candy", "cherry"], key="plum_type_select")
    
    st.markdown(f"### ‚úèÔ∏è Editando reglas para **{plum_type.upper()} PLUM**")
    
    current_plum_rules = st.session_state.edited_plum_rules[plum_type]
    
    col1, col2 = st.columns(2)
    
    with col1:
        # Editor BRIX
        new_brix = create_band_editor("BRIX (%)", current_plum_rules["BRIX"], f"plum_{plum_type}_brix")
        st.session_state.edited_plum_rules[plum_type]["BRIX"] = new_brix
        
        # Editor ACIDEZ
        new_acidez = create_band_editor("ACIDEZ (%)", current_plum_rules["ACIDEZ"], f"plum_{plum_type}_acidez")
        st.session_state.edited_plum_rules[plum_type]["ACIDEZ"] = new_acidez
    
    with col2:
        # Editor FIRMEZA_PUNTO
        new_fp = create_band_editor("FIRMEZA PUNTO", current_plum_rules["FIRMEZA_PUNTO"], f"plum_{plum_type}_fp")
        st.session_state.edited_plum_rules[plum_type]["FIRMEZA_PUNTO"] = new_fp
        
        # Editor FIRMEZA_MEJ
        new_fmej = create_band_editor("FIRMEZA MEJILLAS", current_plum_rules["FIRMEZA_MEJ"], f"plum_{plum_type}_fmej")
        st.session_state.edited_plum_rules[plum_type]["FIRMEZA_MEJ"] = new_fmej
    
    # Botones de acci√≥n
    col1, col2, col3 = st.columns(3)
    with col1:
        if st.button("üîÑ Restaurar Originales", key="reset_plum"):
            st.session_state.edited_plum_rules[plum_type] = copy.deepcopy(PLUM_RULES[plum_type])
            st.success("‚úÖ Reglas restauradas!")
            st.rerun()
    
    with col2:
        if st.button("üíæ Guardar Cambios", key="save_plum"):
            st.success("‚úÖ Cambios guardados en memoria!")
    
    with col3:
        if st.button("üìÑ Ver Reglas JSON", key="show_plum_json"):
            st.json(st.session_state.edited_plum_rules[plum_type])

with tab2:
    st.markdown("""
    <div class="rule-editor">
        <h3>üçë Editor de Reglas para Nectarina</h3>
        <p>Configure las bandas por color (amarilla/blanca) y per√≠odo de cosecha</p>
    </div>
    """, unsafe_allow_html=True)
    
    col1, col2 = st.columns(2)
    with col1:
        nect_color = st.selectbox("üé® Color de Nectarina", ["amarilla", "blanca"], key="nect_color")
    with col2:
        nect_period = st.selectbox("üìÖ Per√≠odo de Cosecha", ["muy_temprana", "temprana", "tardia"], key="nect_period")
    
    st.markdown(f"### ‚úèÔ∏è Editando **NECTARINA {nect_color.upper()} - {nect_period.upper()}**")
    
    current_nect_rules = st.session_state.edited_nect_rules[nect_color][nect_period]
    
    col1, col2 = st.columns(2)
    
    with col1:
        # Editor BRIX
        new_brix_n = create_band_editor("BRIX (%)", current_nect_rules["BRIX"], f"nect_{nect_color}_{nect_period}_brix")
        st.session_state.edited_nect_rules[nect_color][nect_period]["BRIX"] = new_brix_n
        
        # Editor ACIDEZ
        new_acidez_n = create_band_editor("ACIDEZ (%)", current_nect_rules["ACIDEZ"], f"nect_{nect_color}_{nect_period}_acidez")
        st.session_state.edited_nect_rules[nect_color][nect_period]["ACIDEZ"] = new_acidez_n
    
    with col2:
        # Editor FIRMEZA_PUNTO
        new_fp_n = create_band_editor("FIRMEZA PUNTO", current_nect_rules["FIRMEZA_PUNTO"], f"nect_{nect_color}_{nect_period}_fp")
        st.session_state.edited_nect_rules[nect_color][nect_period]["FIRMEZA_PUNTO"] = new_fp_n
        
        # Editor FIRMEZA_MEJ
        new_fmej_n = create_band_editor("FIRMEZA MEJILLAS", current_nect_rules["FIRMEZA_MEJ"], f"nect_{nect_color}_{nect_period}_fmej")
        st.session_state.edited_nect_rules[nect_color][nect_period]["FIRMEZA_MEJ"] = new_fmej_n
    
    # Informaci√≥n de per√≠odos
    st.markdown("""
    <div class="success-card">
        <h4>üìÖ Informaci√≥n de Per√≠odos de Cosecha</h4>
        <strong>Nectarina Blanca:</strong><br>
        ‚Ä¢ Muy Temprana: antes del 25 nov ‚Ä¢ Temprana: 25 nov - 15 dic ‚Ä¢ Tard√≠a: 16 dic - 15 feb<br><br>
        <strong>Nectarina Amarilla:</strong><br>
        ‚Ä¢ Muy Temprana: antes del 22 nov ‚Ä¢ Temprana: 22 nov - 22 dic ‚Ä¢ Tard√≠a: 23 dic - 15 feb
    </div>
    """, unsafe_allow_html=True)
    
    # Botones de acci√≥n
    col1, col2, col3 = st.columns(3)
    with col1:
        if st.button("üîÑ Restaurar Originales", key="reset_nect"):
            st.session_state.edited_nect_rules[nect_color][nect_period] = copy.deepcopy(NECT_RULES[nect_color][nect_period])
            st.success("‚úÖ Reglas restauradas!")
            st.rerun()
    
    with col2:
        if st.button("üíæ Guardar Cambios", key="save_nect"):
            st.success("‚úÖ Cambios guardados en memoria!")
    
    with col3:
        if st.button("üìÑ Ver Reglas JSON", key="show_nect_json"):
            st.json(st.session_state.edited_nect_rules[nect_color][nect_period])

with tab3:
    st.markdown("""
    <div class="success-card">
        <h3>üìä Visualizaciones Interactivas</h3>
        <p>Explore gr√°ficamente las reglas de clustering y sus rangos de aplicaci√≥n</p>
    </div>
    """, unsafe_allow_html=True)
    
    viz_type = st.radio("üìà Tipo de Visualizaci√≥n", ["Ciruela", "Nectarina"], horizontal=True)
    
    if viz_type == "Ciruela":
        viz_subtype = st.selectbox("üç≠ Subtipo", ["candy", "cherry"], key="viz_plum_type")
        rules = st.session_state.edited_plum_rules[viz_subtype]
        
        # Crear subplots
        fig = make_subplots(
            rows=2, cols=2,
            subplot_titles=["BRIX", "FIRMEZA PUNTO", "FIRMEZA MEJILLAS", "ACIDEZ"],
            specs=[[{"secondary_y": False}, {"secondary_y": False}],
                   [{"secondary_y": False}, {"secondary_y": False}]]
        )
        
        metrics = ["BRIX", "FIRMEZA_PUNTO", "FIRMEZA_MEJ", "ACIDEZ"]
        positions = [(1,1), (1,2), (2,1), (2,2)]
        
        for metric, (row, col) in zip(metrics, positions):
            bands = rules[metric]
            # Usar colores pastel est√°ndar
            cluster_colors = get_cluster_colors()
            colors = [cluster_colors['hex'][i] for i in range(1, 5)]
            
            for lo, hi, band in bands:
                lo_display = lo if lo != float('-inf') else 0
                hi_display = hi if hi != float('inf') else 30
                
                fig.add_trace(
                    go.Bar(
                        x=[f"Banda {band}"],
                        y=[hi_display - lo_display],
                        base=lo_display,
                        marker_color=colors[band-1],
                        name=f"{metric} B{band}",
                        showlegend=False,
                        text=f"[{lo}, {hi})",
                        textposition="inside"
                    ),
                    row=row, col=col
                )
        
        fig.update_layout(
            title=f"üçë Visualizaci√≥n Completa - Ciruela {viz_subtype.upper()}",
            height=600,
            template="plotly_dark"
        )
        
        st.plotly_chart(fig, use_container_width=True)
    
    else:  # Nectarina
        col1, col2 = st.columns(2)
        with col1:
            viz_color = st.selectbox("üé® Color", ["amarilla", "blanca"], key="viz_nect_color")
        with col2:
            viz_period = st.selectbox("üìÖ Per√≠odo", ["muy_temprana", "temprana", "tardia"], key="viz_nect_period")
        
        rules = st.session_state.edited_nect_rules[viz_color][viz_period]
        
        # Gr√°fico de radar para mostrar todos los rangos
        categories = ["BRIX", "FIRMEZA_PUNTO", "FIRMEZA_MEJ", "ACIDEZ"]
        
        fig = go.Figure()
        
        for band_num in range(1, 5):
            values = []
            for metric in categories:
                bands = rules[metric]
                for lo, hi, band in bands:
                    if band == band_num:
                        # Usar el punto medio del rango para el radar
                        lo_val = lo if lo != float('-inf') else 0
                        hi_val = hi if hi != float('inf') else 20
                        values.append((lo_val + hi_val) / 2)
                        break
            
            if len(values) == 4:
                fig.add_trace(go.Scatterpolar(
                    r=values,
                    theta=categories,
                    fill='toself',
                    name=f'Banda {band_num}',
                    line_color=colors[band_num-1]
                ))
        
        fig.update_layout(
            polar=dict(
                radialaxis=dict(visible=True, range=[0, 25])
            ),
            title=f"üçë Radar de Bandas - Nectarina {viz_color} {viz_period}",
            template="plotly_dark"
        )
        
        st.plotly_chart(fig, use_container_width=True)

with tab4:
    st.markdown("""
    <div class="warning-card">
        <h3>‚öôÔ∏è Configuraci√≥n y Exportaci√≥n</h3>
        <p>Gestione sus configuraciones personalizadas y exporte las reglas modificadas</p>
    </div>
    """, unsafe_allow_html=True)
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("#### üì§ Exportar Configuraciones")
        
        if st.button("üìÑ Exportar Reglas como JSON", key="export_json"):
            export_data = {
                "plum_rules": st.session_state.edited_plum_rules,
                "nect_rules": st.session_state.edited_nect_rules
            }
            st.download_button(
                label="üíæ Descargar JSON",
                data=str(export_data),
                file_name="reglas_clustering_personalizadas.json",
                mime="application/json"
            )
        
        if st.button("üìä Exportar como Python Code", key="export_python"):
            python_code = f"""
# Reglas de clustering personalizadas
PLUM_RULES = {st.session_state.edited_plum_rules}

NECT_RULES = {st.session_state.edited_nect_rules}
"""
            st.download_button(
                label="üíæ Descargar .py",
                data=python_code,
                file_name="reglas_personalizadas.py",
                mime="text/plain"
            )
    
    with col2:
        st.markdown("#### üîÑ Acciones de Sistema")
        
        if st.button("üîÑ Restaurar TODAS las Reglas", key="reset_all"):
            st.session_state.edited_plum_rules = copy.deepcopy(PLUM_RULES)
            st.session_state.edited_nect_rules = copy.deepcopy(NECT_RULES)
            st.success("‚úÖ Todas las reglas restauradas a valores originales!")
            st.rerun()
        
        if st.button("üìã Mostrar Diferencias", key="show_diff"):
            st.markdown("**üîç Comparaci√≥n con Reglas Originales:**")
            
            # Comparar cambios en Ciruela
            for ptype in ["candy", "cherry"]:
                original = PLUM_RULES[ptype]
                edited = st.session_state.edited_plum_rules[ptype]
                if original != edited:
                    st.warning(f"Ciruela {ptype}: ¬°Modificada!")
                else:
                    st.success(f"Ciruela {ptype}: Sin cambios")
            
            # Comparar cambios en Nectarina
            for color in ["amarilla", "blanca"]:
                for period in ["muy_temprana", "temprana", "tardia"]:
                    original = NECT_RULES[color][period]
                    edited = st.session_state.edited_nect_rules[color][period]
                    if original != edited:
                        st.warning(f"Nectarina {color} {period}: ¬°Modificada!")
                    else:
                        st.success(f"Nectarina {color} {period}: Sin cambios")

# Informaci√≥n final
st.markdown("---")
st.markdown("""
<div class="metric-card">
    <h4>üéØ Informaci√≥n del Sistema de Bandas</h4>
    <p><strong>Cluster Final = Suma de Bandas:</strong></p>
    <p>üü¢ Cluster 1: Suma 3-5 (Excelente) | üü° Cluster 2: Suma 6-8 (Bueno) | üü† Cluster 3: Suma 9-11 (Regular) | üî¥ Cluster 4: Suma 12+ (Deficiente)</p>
    <p><strong>üìè M√©tricas:</strong> BRIX (s√≥lidos solubles) ‚Ä¢ FIRMEZA_PUNTO (punto m√°s d√©bil) ‚Ä¢ FIRMEZA_MEJ (promedio mejillas) ‚Ä¢ ACIDEZ (primer fruto)</p>
</div>
""", unsafe_allow_html=True)

with tab5:
    st.markdown("""
    <div class="info-card">
        <h3>‚ûï Creador de Nuevas M√©tricas</h3>
        <p>Define m√©tricas personalizadas para tu an√°lisis de clustering</p>
    </div>
    """, unsafe_allow_html=True)
    
    # Inicializar session state para m√©tricas personalizadas
    if "custom_metrics" not in st.session_state:
        st.session_state.custom_metrics = {}
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("### üîß Configurar Nueva M√©trica")
        
        # Nombre de la m√©trica
        metric_name = st.text_input(
            "üìù Nombre de la M√©trica:",
            placeholder="Ej: TEXTURA_SUPERFICIE",
            key="new_metric_name"
        )
        
        # Tipo de m√©trica
        metric_type = st.selectbox(
            "üìä Tipo de M√©trica:",
            ["Num√©rica Continua", "Num√©rica Discreta", "Categ√≥rica"],
            key="metric_type"
        )
        
        # Descripci√≥n
        metric_description = st.text_area(
            "üìã Descripci√≥n:",
            placeholder="Describe qu√© mide esta m√©trica y c√≥mo se obtiene...",
            key="metric_description"
        )
        
        # Unidad de medida
        metric_unit = st.text_input(
            "üè∑Ô∏è Unidad de Medida:",
            placeholder="Ej: %, cm, kg, puntos",
            key="metric_unit"
        )
        
        # Rango esperado
        st.markdown("#### üìè Rango de Valores")
        col_min, col_max = st.columns(2)
        with col_min:
            metric_min = st.number_input(
                "Valor M√≠nimo:",
                value=0.0,
                key="metric_min"
            )
        with col_max:
            metric_max = st.number_input(
                "Valor M√°ximo:",
                value=100.0,
                key="metric_max"
            )
    
    with col2:
        st.markdown("### üéØ Definir Bandas de Clasificaci√≥n")
        
        if metric_name:
            st.markdown(f"**Configurando bandas para:** {metric_name}")
            
            # N√∫mero de bandas
            num_bands = st.selectbox(
                "üî¢ N√∫mero de Bandas:",
                [3, 4, 5],
                index=1,  # Default 4 bandas
                key="num_bands"
            )
            
            # Configurar cada banda
            bands_config = []
            band_colors = ["üü¢ Excelente", "üü° Bueno", "üü† Regular", "üü£ Deficiente"]
            
            for i in range(num_bands):
                st.markdown(f"#### {band_colors[i]} - Banda {i+1}")
                
                col_band_min, col_band_max = st.columns(2)
                with col_band_min:
                    if i == 0:
                        band_min = st.number_input(
                            f"M√≠nimo B{i+1}:",
                            value=metric_min,
                            key=f"band_{i}_min"
                        )
                    else:
                        band_min = bands_config[i-1]['max']
                        st.info(f"M√≠nimo: {band_min}")
                
                with col_band_max:
                    if i == num_bands - 1:
                        band_max = metric_max
                        st.info(f"M√°ximo: {band_max}")
                    else:
                        band_max = st.number_input(
                            f"M√°ximo B{i+1}:",
                            value=metric_min + ((metric_max - metric_min) / num_bands) * (i+1),
                            key=f"band_{i}_max"
                        )
                
                bands_config.append({
                    'band': i+1,
                    'min': band_min,
                    'max': band_max,
                    'label': band_colors[i]
                })
    
    # Guardar m√©trica personalizada
    col1, col2, col3 = st.columns(3)
    
    with col1:
        if st.button("üíæ Guardar M√©trica", key="save_custom_metric"):
            if metric_name and metric_description:
                # Crear estructura de la m√©trica
                custom_metric = {
                    'name': metric_name,
                    'type': metric_type,
                    'description': metric_description,
                    'unit': metric_unit,
                    'min_value': metric_min,
                    'max_value': metric_max,
                    'bands': bands_config,
                    'created_at': pd.Timestamp.now()
                }
                
                # Guardar en session state
                st.session_state.custom_metrics[metric_name] = custom_metric
                
                st.success(f"‚úÖ M√©trica '{metric_name}' guardada exitosamente!")
                st.rerun()
            else:
                st.error("‚ùå Por favor completa al menos el nombre y descripci√≥n de la m√©trica.")
    
    with col2:
        if st.button("üìÑ Exportar M√©trica", key="export_custom_metric"):
            if metric_name in st.session_state.custom_metrics:
                metric_data = st.session_state.custom_metrics[metric_name]
                
                # Convertir a JSON
                import json
                metric_json = json.dumps(metric_data, default=str, indent=2)
                
                st.download_button(
                    label="üíæ Descargar JSON",
                    data=metric_json,
                    file_name=f"metrica_{metric_name.lower()}.json",
                    mime="application/json"
                )
    
    with col3:
        if st.button("üóëÔ∏è Limpiar Formulario", key="clear_form"):
            for key in ['new_metric_name', 'metric_description', 'metric_unit']:
                if key in st.session_state:
                    del st.session_state[key]
            st.rerun()
    
    # Mostrar m√©tricas existentes
    if st.session_state.custom_metrics:
        st.markdown("---")
        st.markdown("### üìã M√©tricas Personalizadas Creadas")
        
        for name, metric in st.session_state.custom_metrics.items():
            with st.expander(f"üìä {name} ({metric['unit']})"):
                col1, col2 = st.columns(2)
                
                with col1:
                    st.markdown(f"**Tipo:** {metric['type']}")
                    st.markdown(f"**Descripci√≥n:** {metric['description']}")
                    st.markdown(f"**Rango:** {metric['min_value']} - {metric['max_value']} {metric['unit']}")
                    st.markdown(f"**Creada:** {metric['created_at'].strftime('%Y-%m-%d %H:%M')}")
                
                with col2:
                    st.markdown("**Bandas de Clasificaci√≥n:**")
                    for band in metric['bands']:
                        st.markdown(f"‚Ä¢ {band['label']}: {band['min']} - {band['max']} {metric['unit']}")
                
                # Botones de acci√≥n
                col_action1, col_action2, col_action3 = st.columns(3)
                
                with col_action1:
                    if st.button(f"üìù Editar {name}", key=f"edit_{name}"):
                        st.info("üîß Para editar, modifica los valores arriba y guarda de nuevo.")
                
                with col_action2:
                    if st.button(f"üìÑ Exportar {name}", key=f"export_{name}"):
                        import json
                        metric_json = json.dumps(metric, default=str, indent=2)
                        st.download_button(
                            label="üíæ Descargar",
                            data=metric_json,
                            file_name=f"metrica_{name.lower()}.json",
                            mime="application/json",
                            key=f"download_{name}"
                        )
                
                with col_action3:
                    if st.button(f"üóëÔ∏è Eliminar {name}", key=f"delete_{name}"):
                        del st.session_state.custom_metrics[name]
                        st.success(f"‚úÖ M√©trica '{name}' eliminada.")
                        st.rerun()
    
    else:
        st.info("üìù No hay m√©tricas personalizadas creadas a√∫n. ¬°Crea tu primera m√©trica usando el formulario arriba!")
    
    # Importar m√©tricas desde JSON
    st.markdown("---")
    st.markdown("### üì§ Importar M√©tricas")
    
    uploaded_metric = st.file_uploader(
        "üìÅ Cargar M√©trica desde JSON:",
        type=['json'],
        key="upload_metric"
    )
    
    if uploaded_metric is not None:
        try:
            import json
            metric_data = json.load(uploaded_metric)
            
            # Validar estructura b√°sica
            required_fields = ['name', 'type', 'description', 'bands']
            if all(field in metric_data for field in required_fields):
                
                # Guardar m√©trica importada
                metric_name = metric_data['name']
                st.session_state.custom_metrics[metric_name] = metric_data
                
                st.success(f"‚úÖ M√©trica '{metric_name}' importada exitosamente!")
                st.rerun()
            else:
                st.error("‚ùå El archivo JSON no tiene la estructura correcta de una m√©trica.")
        except Exception as e:
            st.error(f"‚ùå Error al cargar el archivo: {str(e)}")

st.success("üéâ ¬°Sistema de reglas interactivo funcionando correctamente! Todas las modificaciones se aplican en tiempo real.")